// Copyright Â© 2025 Ping Identity Corporation
/*
PingOne User and Configuration Management API

The PingOne User and Configuration Management API provides the interface to configure and manage users in the PingOne directory and the administration configuration of your PingOne organization.

Contact: developerexperiences@pingidentity.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pingone

import (
	"bytes"
	"context"
	"errors"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/google/uuid"
)

// DaVinciApplicationApiService DaVinciApplicationApi service
type DaVinciApplicationApiService service

type ApiCreateDavinciApplicationRequest struct {
	ctx                             context.Context
	ApiService                      *DaVinciApplicationApiService
	environmentID                   uuid.UUID
	daVinciApplicationCreateRequest *DaVinciApplicationCreateRequest
	xPingExternalTransactionID      *string
	xPingExternalSessionID          *string
}

func (r ApiCreateDavinciApplicationRequest) DaVinciApplicationCreateRequest(daVinciApplicationCreateRequest DaVinciApplicationCreateRequest) ApiCreateDavinciApplicationRequest {
	r.daVinciApplicationCreateRequest = &daVinciApplicationCreateRequest
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiCreateDavinciApplicationRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiCreateDavinciApplicationRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiCreateDavinciApplicationRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiCreateDavinciApplicationRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiCreateDavinciApplicationRequest) Execute() (*DaVinciApplication, *http.Response, error) {
	return r.ApiService.CreateDavinciApplicationExecute(r)
}

/*
CreateDavinciApplication _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:create:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiCreateDavinciApplicationRequest
*/
func (a *DaVinciApplicationApiService) CreateDavinciApplication(ctx context.Context, environmentID uuid.UUID) ApiCreateDavinciApplicationRequest {
	return ApiCreateDavinciApplicationRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return DaVinciApplication
func (a *DaVinciApplicationApiService) CreateDavinciApplicationExecute(r ApiCreateDavinciApplicationRequest) (*DaVinciApplication, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.CreateDavinciApplication")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.daVinciApplicationCreateRequest == nil {
		return localVarReturnValue, nil, reportError("daVinciApplicationCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.daVinciApplicationCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateFlowPolicyByDavinciApplicationIdRequest struct {
	ctx                            context.Context
	ApiService                     *DaVinciApplicationApiService
	environmentID                  uuid.UUID
	daVinciApplicationID           string
	daVinciFlowPolicyCreateRequest *DaVinciFlowPolicyCreateRequest
	xPingExternalTransactionID     *string
	xPingExternalSessionID         *string
}

func (r ApiCreateFlowPolicyByDavinciApplicationIdRequest) DaVinciFlowPolicyCreateRequest(daVinciFlowPolicyCreateRequest DaVinciFlowPolicyCreateRequest) ApiCreateFlowPolicyByDavinciApplicationIdRequest {
	r.daVinciFlowPolicyCreateRequest = &daVinciFlowPolicyCreateRequest
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiCreateFlowPolicyByDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiCreateFlowPolicyByDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiCreateFlowPolicyByDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiCreateFlowPolicyByDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiCreateFlowPolicyByDavinciApplicationIdRequest) Execute() (*DaVinciFlowPolicyResponse, *http.Response, error) {
	return r.ApiService.CreateFlowPolicyByDavinciApplicationIdExecute(r)
}

/*
CreateFlowPolicyByDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:create:flowPolicies
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiCreateFlowPolicyByDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) CreateFlowPolicyByDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiCreateFlowPolicyByDavinciApplicationIdRequest {
	return ApiCreateFlowPolicyByDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
//
//	@return DaVinciFlowPolicyResponse
func (a *DaVinciApplicationApiService) CreateFlowPolicyByDavinciApplicationIdExecute(r ApiCreateFlowPolicyByDavinciApplicationIdRequest) (*DaVinciFlowPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciFlowPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.CreateFlowPolicyByDavinciApplicationId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/flowPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.daVinciFlowPolicyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("daVinciFlowPolicyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.daVinciFlowPolicyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateKeyByDavinciApplicationIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	requestBody                *map[string]interface{}
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

func (r ApiCreateKeyByDavinciApplicationIdRequest) RequestBody(requestBody map[string]interface{}) ApiCreateKeyByDavinciApplicationIdRequest {
	r.requestBody = &requestBody
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiCreateKeyByDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiCreateKeyByDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiCreateKeyByDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiCreateKeyByDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiCreateKeyByDavinciApplicationIdRequest) Execute() (*DaVinciApplication, *http.Response, error) {
	return r.ApiService.CreateKeyByDavinciApplicationIdExecute(r)
}

/*
CreateKeyByDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:update:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiCreateKeyByDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) CreateKeyByDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiCreateKeyByDavinciApplicationIdRequest {
	return ApiCreateKeyByDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
//
//	@return DaVinciApplication
func (a *DaVinciApplicationApiService) CreateKeyByDavinciApplicationIdExecute(r ApiCreateKeyByDavinciApplicationIdRequest) (*DaVinciApplication, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.CreateKeyByDavinciApplicationId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/key"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.pingidentity.davinciApplication.rotateKey+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSecretByDavinciApplicationIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	requestBody                *map[string]interface{}
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

func (r ApiCreateSecretByDavinciApplicationIdRequest) RequestBody(requestBody map[string]interface{}) ApiCreateSecretByDavinciApplicationIdRequest {
	r.requestBody = &requestBody
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiCreateSecretByDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiCreateSecretByDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiCreateSecretByDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiCreateSecretByDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiCreateSecretByDavinciApplicationIdRequest) Execute() (*DaVinciApplication, *http.Response, error) {
	return r.ApiService.CreateSecretByDavinciApplicationIdExecute(r)
}

/*
CreateSecretByDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:update:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiCreateSecretByDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) CreateSecretByDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiCreateSecretByDavinciApplicationIdRequest {
	return ApiCreateSecretByDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
//
//	@return DaVinciApplication
func (a *DaVinciApplicationApiService) CreateSecretByDavinciApplicationIdExecute(r ApiCreateSecretByDavinciApplicationIdRequest) (*DaVinciApplication, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.CreateSecretByDavinciApplicationId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/secret"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/vnd.pingidentity.davinciApplication.rotateSecret+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDavinciApplicationByIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiDeleteDavinciApplicationByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiDeleteDavinciApplicationByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiDeleteDavinciApplicationByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiDeleteDavinciApplicationByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiDeleteDavinciApplicationByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDavinciApplicationByIdExecute(r)
}

/*
DeleteDavinciApplicationById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:delete:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiDeleteDavinciApplicationByIdRequest
*/
func (a *DaVinciApplicationApiService) DeleteDavinciApplicationById(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiDeleteDavinciApplicationByIdRequest {
	return ApiDeleteDavinciApplicationByIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
func (a *DaVinciApplicationApiService) DeleteDavinciApplicationByIdExecute(r ApiDeleteDavinciApplicationByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.DeleteDavinciApplicationById")
	if err != nil {
		return nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
			}
			return localVarHTTPResponse, newErr
		}
		break
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	flowPolicyID               string
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFlowPolicyByIdUsingDavinciApplicationIdExecute(r)
}

/*
DeleteFlowPolicyByIdUsingDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:delete:flowPolicies
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@param flowPolicyID
	@return ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) DeleteFlowPolicyByIdUsingDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string, flowPolicyID string) ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest {
	return ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
		flowPolicyID:         flowPolicyID,
	}
}

// Execute executes the request
func (a *DaVinciApplicationApiService) DeleteFlowPolicyByIdUsingDavinciApplicationIdExecute(r ApiDeleteFlowPolicyByIdUsingDavinciApplicationIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.DeleteFlowPolicyByIdUsingDavinciApplicationId")
	if err != nil {
		return nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/flowPolicies/{flowPolicyID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowPolicyID"+"}", url.PathEscape(parameterValueToString(r.flowPolicyID, "flowPolicyID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
			}
			return localVarHTTPResponse, newErr
		}
		break
	}

	return localVarHTTPResponse, nil
}

type ApiGetDavinciApplicationByIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetDavinciApplicationByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetDavinciApplicationByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetDavinciApplicationByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetDavinciApplicationByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetDavinciApplicationByIdRequest) Execute() (*DaVinciApplication, *http.Response, error) {
	return r.ApiService.GetDavinciApplicationByIdExecute(r)
}

/*
GetDavinciApplicationById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:read:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiGetDavinciApplicationByIdRequest
*/
func (a *DaVinciApplicationApiService) GetDavinciApplicationById(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiGetDavinciApplicationByIdRequest {
	return ApiGetDavinciApplicationByIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
//
//	@return DaVinciApplication
func (a *DaVinciApplicationApiService) GetDavinciApplicationByIdExecute(r ApiGetDavinciApplicationByIdRequest) (*DaVinciApplication, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.GetDavinciApplicationById")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDavinciApplicationsRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetDavinciApplicationsRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetDavinciApplicationsRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetDavinciApplicationsRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetDavinciApplicationsRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetDavinciApplicationsRequest) Execute() (*DaVinciApplicationCollection, *http.Response, error) {
	return r.ApiService.GetDavinciApplicationsExecute(r)
}

/*
GetDavinciApplications _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:read:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiGetDavinciApplicationsRequest
*/
func (a *DaVinciApplicationApiService) GetDavinciApplications(ctx context.Context, environmentID uuid.UUID) ApiGetDavinciApplicationsRequest {
	return ApiGetDavinciApplicationsRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return DaVinciApplicationCollection
func (a *DaVinciApplicationApiService) GetDavinciApplicationsExecute(r ApiGetDavinciApplicationsRequest) (*DaVinciApplicationCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciApplicationCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.GetDavinciApplications")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowPoliciesByDavinciApplicationIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetFlowPoliciesByDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetFlowPoliciesByDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetFlowPoliciesByDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetFlowPoliciesByDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetFlowPoliciesByDavinciApplicationIdRequest) Execute() (*DaVinciFlowPolicyCollection, *http.Response, error) {
	return r.ApiService.GetFlowPoliciesByDavinciApplicationIdExecute(r)
}

/*
GetFlowPoliciesByDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:read:flowPolicies
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiGetFlowPoliciesByDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) GetFlowPoliciesByDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiGetFlowPoliciesByDavinciApplicationIdRequest {
	return ApiGetFlowPoliciesByDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
//
//	@return DaVinciFlowPolicyCollection
func (a *DaVinciApplicationApiService) GetFlowPoliciesByDavinciApplicationIdExecute(r ApiGetFlowPoliciesByDavinciApplicationIdRequest) (*DaVinciFlowPolicyCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciFlowPolicyCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.GetFlowPoliciesByDavinciApplicationId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/flowPolicies"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciApplicationApiService
	environmentID              uuid.UUID
	daVinciApplicationID       string
	flowPolicyID               string
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest) Execute() (*DaVinciFlowPolicyResponse, *http.Response, error) {
	return r.ApiService.GetFlowPolicyByIdUsingDavinciApplicationIdExecute(r)
}

/*
GetFlowPolicyByIdUsingDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:read:flowPolicies
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@param flowPolicyID
	@return ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) GetFlowPolicyByIdUsingDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string, flowPolicyID string) ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest {
	return ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
		flowPolicyID:         flowPolicyID,
	}
}

// Execute executes the request
//
//	@return DaVinciFlowPolicyResponse
func (a *DaVinciApplicationApiService) GetFlowPolicyByIdUsingDavinciApplicationIdExecute(r ApiGetFlowPolicyByIdUsingDavinciApplicationIdRequest) (*DaVinciFlowPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciFlowPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.GetFlowPolicyByIdUsingDavinciApplicationId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/flowPolicies/{flowPolicyID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowPolicyID"+"}", url.PathEscape(parameterValueToString(r.flowPolicyID, "flowPolicyID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceDavinciApplicationByIdRequest struct {
	ctx                              context.Context
	ApiService                       *DaVinciApplicationApiService
	environmentID                    uuid.UUID
	daVinciApplicationID             string
	daVinciApplicationReplaceRequest *DaVinciApplicationReplaceRequest
	xPingExternalTransactionID       *string
	xPingExternalSessionID           *string
}

func (r ApiReplaceDavinciApplicationByIdRequest) DaVinciApplicationReplaceRequest(daVinciApplicationReplaceRequest DaVinciApplicationReplaceRequest) ApiReplaceDavinciApplicationByIdRequest {
	r.daVinciApplicationReplaceRequest = &daVinciApplicationReplaceRequest
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiReplaceDavinciApplicationByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiReplaceDavinciApplicationByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiReplaceDavinciApplicationByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiReplaceDavinciApplicationByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiReplaceDavinciApplicationByIdRequest) Execute() (*DaVinciApplication, *http.Response, error) {
	return r.ApiService.ReplaceDavinciApplicationByIdExecute(r)
}

/*
ReplaceDavinciApplicationById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:update:applications
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@return ApiReplaceDavinciApplicationByIdRequest
*/
func (a *DaVinciApplicationApiService) ReplaceDavinciApplicationById(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string) ApiReplaceDavinciApplicationByIdRequest {
	return ApiReplaceDavinciApplicationByIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
	}
}

// Execute executes the request
//
//	@return DaVinciApplication
func (a *DaVinciApplicationApiService) ReplaceDavinciApplicationByIdExecute(r ApiReplaceDavinciApplicationByIdRequest) (*DaVinciApplication, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciApplication
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.ReplaceDavinciApplicationById")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.daVinciApplicationReplaceRequest == nil {
		return localVarReturnValue, nil, reportError("daVinciApplicationReplaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.daVinciApplicationReplaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest struct {
	ctx                             context.Context
	ApiService                      *DaVinciApplicationApiService
	environmentID                   uuid.UUID
	daVinciApplicationID            string
	flowPolicyID                    string
	daVinciFlowPolicyReplaceRequest *DaVinciFlowPolicyReplaceRequest
	xPingExternalTransactionID      *string
	xPingExternalSessionID          *string
}

func (r ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest) DaVinciFlowPolicyReplaceRequest(daVinciFlowPolicyReplaceRequest DaVinciFlowPolicyReplaceRequest) ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.daVinciFlowPolicyReplaceRequest = &daVinciFlowPolicyReplaceRequest
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest) Execute() (*DaVinciFlowPolicyResponse, *http.Response, error) {
	return r.ApiService.ReplaceFlowPolicyByIdUsingDavinciApplicationIdExecute(r)
}

/*
ReplaceFlowPolicyByIdUsingDavinciApplicationId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:update:flowPolicies
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param daVinciApplicationID
	@param flowPolicyID
	@return ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest
*/
func (a *DaVinciApplicationApiService) ReplaceFlowPolicyByIdUsingDavinciApplicationId(ctx context.Context, environmentID uuid.UUID, daVinciApplicationID string, flowPolicyID string) ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest {
	return ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest{
		ApiService:           a,
		ctx:                  ctx,
		environmentID:        environmentID,
		daVinciApplicationID: daVinciApplicationID,
		flowPolicyID:         flowPolicyID,
	}
}

// Execute executes the request
//
//	@return DaVinciFlowPolicyResponse
func (a *DaVinciApplicationApiService) ReplaceFlowPolicyByIdUsingDavinciApplicationIdExecute(r ApiReplaceFlowPolicyByIdUsingDavinciApplicationIdRequest) (*DaVinciFlowPolicyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciFlowPolicyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciApplicationApiService.ReplaceFlowPolicyByIdUsingDavinciApplicationId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/davinciApplications/{daVinciApplicationID}/flowPolicies/{flowPolicyID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"daVinciApplicationID"+"}", url.PathEscape(parameterValueToString(r.daVinciApplicationID, "daVinciApplicationID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"flowPolicyID"+"}", url.PathEscape(parameterValueToString(r.flowPolicyID, "flowPolicyID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.daVinciFlowPolicyReplaceRequest == nil {
		return localVarReturnValue, nil, reportError("daVinciFlowPolicyReplaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.daVinciFlowPolicyReplaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
