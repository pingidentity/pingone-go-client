// Copyright Â© 2025 Ping Identity Corporation
/*
PingOne User and Configuration Management API

The PingOne User and Configuration Management API provides the interface to configure and manage users in the PingOne directory and the administration configuration of your PingOne organization.

Contact: developerexperiences@pingidentity.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pingone

import (
	"bytes"
	"context"
	"errors"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/google/uuid"
)

// DaVinciVariableApiService DaVinciVariableApi service
type DaVinciVariableApiService service

type ApiCreateVariableRequest struct {
	ctx                          context.Context
	ApiService                   *DaVinciVariableApiService
	environmentID                uuid.UUID
	daVinciVariableCreateRequest *DaVinciVariableCreateRequest
	xPingExternalTransactionID   *string
	xPingExternalSessionID       *string
}

func (r ApiCreateVariableRequest) DaVinciVariableCreateRequest(daVinciVariableCreateRequest DaVinciVariableCreateRequest) ApiCreateVariableRequest {
	r.daVinciVariableCreateRequest = &daVinciVariableCreateRequest
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiCreateVariableRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiCreateVariableRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiCreateVariableRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiCreateVariableRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiCreateVariableRequest) Execute() (*DaVinciVariable, *http.Response, error) {
	return r.ApiService.CreateVariableExecute(r)
}

/*
CreateVariable Create DaVinci Variable

Creates a new DaVinci variable resource. You must specify a `name`, `dataType`, and `context` for the variable.

	@permission davinci:create:constructs
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiCreateVariableRequest
*/
func (a *DaVinciVariableApiService) CreateVariable(ctx context.Context, environmentID uuid.UUID) ApiCreateVariableRequest {
	return ApiCreateVariableRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return DaVinciVariable
func (a *DaVinciVariableApiService) CreateVariableExecute(r ApiCreateVariableRequest) (*DaVinciVariable, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciVariableApiService.CreateVariable")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.daVinciVariableCreateRequest == nil {
		return localVarReturnValue, nil, reportError("daVinciVariableCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.daVinciVariableCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteVariableByIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciVariableApiService
	environmentID              uuid.UUID
	variableID                 uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiDeleteVariableByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiDeleteVariableByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiDeleteVariableByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiDeleteVariableByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiDeleteVariableByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteVariableByIdExecute(r)
}

/*
DeleteVariableById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:delete:constructs
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param variableID _TO_BE_DEFINED_
	@return ApiDeleteVariableByIdRequest
*/
func (a *DaVinciVariableApiService) DeleteVariableById(ctx context.Context, environmentID uuid.UUID, variableID uuid.UUID) ApiDeleteVariableByIdRequest {
	return ApiDeleteVariableByIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
		variableID:    variableID,
	}
}

// Execute executes the request
func (a *DaVinciVariableApiService) DeleteVariableByIdExecute(r ApiDeleteVariableByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciVariableApiService.DeleteVariableById")
	if err != nil {
		return nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/variables/{variableID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variableID"+"}", url.PathEscape(parameterValueToString(r.variableID, "variableID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
				return localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarHTTPResponse, newErr
				}
			}
			return localVarHTTPResponse, newErr
		}
		break
	}

	return localVarHTTPResponse, nil
}

type ApiGetVariableByIdRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciVariableApiService
	environmentID              uuid.UUID
	variableID                 uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetVariableByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetVariableByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetVariableByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetVariableByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetVariableByIdRequest) Execute() (*DaVinciVariable, *http.Response, error) {
	return r.ApiService.GetVariableByIdExecute(r)
}

/*
GetVariableById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:read:constructs
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param variableID _TO_BE_DEFINED_
	@return ApiGetVariableByIdRequest
*/
func (a *DaVinciVariableApiService) GetVariableById(ctx context.Context, environmentID uuid.UUID, variableID uuid.UUID) ApiGetVariableByIdRequest {
	return ApiGetVariableByIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
		variableID:    variableID,
	}
}

// Execute executes the request
//
//	@return DaVinciVariable
func (a *DaVinciVariableApiService) GetVariableByIdExecute(r ApiGetVariableByIdRequest) (*DaVinciVariable, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciVariableApiService.GetVariableById")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/variables/{variableID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variableID"+"}", url.PathEscape(parameterValueToString(r.variableID, "variableID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVariablesRequest struct {
	ctx                        context.Context
	ApiService                 *DaVinciVariableApiService
	environmentID              uuid.UUID
	limit                      *int32
	cursor                     *string
	filter                     *string
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

func (r ApiGetVariablesRequest) Limit(limit int32) ApiGetVariablesRequest {
	r.limit = &limit
	return r
}

func (r ApiGetVariablesRequest) Cursor(cursor string) ApiGetVariablesRequest {
	r.cursor = &cursor
	return r
}

func (r ApiGetVariablesRequest) Filter(filter string) ApiGetVariablesRequest {
	r.filter = &filter
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetVariablesRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetVariablesRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetVariablesRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetVariablesRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetVariablesRequest) Execute() PagedIterator[DaVinciVariableCollection] {
	return r.ApiService.GetVariablesExecute(r)
}

func (r ApiGetVariablesRequest) ExecuteInitialPage() (*DaVinciVariableCollection, *http.Response, error) {
	return r.ApiService.GetVariablesExecutePage(r, nil)
}

func (r ApiGetVariablesRequest) executePageByLink(link JSONHALLink) (*DaVinciVariableCollection, *http.Response, error) {
	return r.ApiService.GetVariablesExecutePage(r, &link)
}

/*
GetVariables _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:read:constructs
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiGetVariablesRequest
*/
func (a *DaVinciVariableApiService) GetVariables(ctx context.Context, environmentID uuid.UUID) ApiGetVariablesRequest {
	return ApiGetVariablesRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return DaVinciVariableCollection
func (a *DaVinciVariableApiService) GetVariablesExecute(r ApiGetVariablesRequest) PagedIterator[DaVinciVariableCollection] {
	return paginationIterator(r.ExecuteInitialPage, r.executePageByLink)
}

// Execute executes the request (returning the initial page of the paged response only)
//
//	@return DaVinciVariableCollection
func (a *DaVinciVariableApiService) GetVariablesExecutePage(r ApiGetVariablesRequest, link *JSONHALLink) (*DaVinciVariableCollection, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciVariableCollection
	)

	var linkUrl *url.URL
	if link != nil {
		var err error
		linkUrl, err = url.Parse(link.Href)
		if err != nil {
			return localVarReturnValue, nil, &APIError{error: err.Error()}
		}
	}

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciVariableApiService.GetVariables")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 10
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "form", "")
	}

	// overwrite query params with link URL query params if provided
	if linkUrl != nil {
		localVarQueryParams = linkUrl.Query()
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	if linkUrl != nil && linkUrl.Host != req.Host {
		slog.Error("link host does not match expected host", "expected host", req.Host, "provided link host", linkUrl.Host)
		return localVarReturnValue, nil, reportError("link host does not match expected host")
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment created recently - DOCS-8830
				retryEnvironmentResponse, retryVarHTTPResponse, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				if retryVarHTTPResponse.StatusCode == 200 && retryEnvironmentResponse != nil {
					// Check if the retryEnvironmentResponse.CreatedAt is within the last 30 seconds
					if time.Since(retryEnvironmentResponse.CreatedAt) < 30*time.Second {
						slog.Debug("The environment was created within the last 30 seconds, retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
						// Retry the request
						time.Sleep(1 * time.Second)
						continue
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceVariableByIdRequest struct {
	ctx                           context.Context
	ApiService                    *DaVinciVariableApiService
	environmentID                 uuid.UUID
	variableID                    uuid.UUID
	daVinciVariableReplaceRequest *DaVinciVariableReplaceRequest
	xPingExternalTransactionID    *string
	xPingExternalSessionID        *string
}

func (r ApiReplaceVariableByIdRequest) DaVinciVariableReplaceRequest(daVinciVariableReplaceRequest DaVinciVariableReplaceRequest) ApiReplaceVariableByIdRequest {
	r.daVinciVariableReplaceRequest = &daVinciVariableReplaceRequest
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiReplaceVariableByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiReplaceVariableByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiReplaceVariableByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiReplaceVariableByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiReplaceVariableByIdRequest) Execute() (*DaVinciVariable, *http.Response, error) {
	return r.ApiService.ReplaceVariableByIdExecute(r)
}

/*
ReplaceVariableById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission davinci:update:constructs
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@param variableID _TO_BE_DEFINED_
	@return ApiReplaceVariableByIdRequest
*/
func (a *DaVinciVariableApiService) ReplaceVariableById(ctx context.Context, environmentID uuid.UUID, variableID uuid.UUID) ApiReplaceVariableByIdRequest {
	return ApiReplaceVariableByIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
		variableID:    variableID,
	}
}

// Execute executes the request
//
//	@return DaVinciVariable
func (a *DaVinciVariableApiService) ReplaceVariableByIdExecute(r ApiReplaceVariableByIdRequest) (*DaVinciVariable, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DaVinciVariable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DaVinciVariableApiService.ReplaceVariableById")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/variables/{variableID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variableID"+"}", url.PathEscape(parameterValueToString(r.variableID, "variableID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.daVinciVariableReplaceRequest == nil {
		return localVarReturnValue, nil, reportError("daVinciVariableReplaceRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.daVinciVariableReplaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	var bodyBytes []byte
	if req.Body != nil {
		bodyBytes, _ = io.ReadAll(req.Body)
	}

	var localVarHTTPResponse *http.Response
	var localVarBody []byte

	for i := range maxRetries {
		if req.Body != nil {
			req.Body = io.NopCloser(bytes.NewBuffer(bodyBytes))
		}

		if i > 0 {
			slog.Debug("Retrying request", "attempt", i, "method", localVarHTTPMethod, "path", localVarPath)
		}

		localVarHTTPResponse, err = a.client.callAPI(req)
		if err != nil || localVarHTTPResponse == nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

		localVarBody, err = io.ReadAll(localVarHTTPResponse.Body)
		localVarHTTPResponse.Body.Close()
		localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
		if err != nil {
			return localVarReturnValue, localVarHTTPResponse, err
		}

		if localVarHTTPResponse.StatusCode >= 300 {
			newErr := &APIError{
				body:  localVarBody,
				error: localVarHTTPResponse.Status,
			}
			if localVarHTTPResponse.StatusCode == 400 {
				var v ErrorResponseBadRequest
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 401 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 403 {
				var v AccessFailedError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				// check if environment exists - P14C-63085
				_, _, err := a.client.EnvironmentApi.GetEnvironmentById(r.ctx, r.environmentID).Execute()
				if err != nil {
					var notFoundErr NotFoundError
					if errors.As(err, &notFoundErr) {
						slog.Info("The API's error response is inconsistent with that of the containing environment. The environment has not been found", "API error", v, "parent environment error", notFoundErr)
						return localVarReturnValue, localVarHTTPResponse, errors.Join(notFoundErr, err)
					}
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 404 {
				var v NotFoundError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 415 {
				var v InvalidRequestError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
				return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
			}
			if localVarHTTPResponse.StatusCode == 500 {
				var v UnexpectedServiceError
				err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHTTPResponse, newErr
				}
			}
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		break
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
