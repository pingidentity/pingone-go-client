/*
PingOne User and Configuration Management API

The PingOne User and Configuration Management API provides the interface to configure and manage users in the PingOne directory and the administration configuration of your PingOne organization.

Contact: developerexperiences@pingidentity.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package pingone

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/google/uuid"
)

// EnvironmentApiService EnvironmentApi service
type EnvironmentApiService service

type ApiCreateEnvironmentRequest struct {
	ctx                        context.Context
	ApiService                 *EnvironmentApiService
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
	environmentCreateRequest   *EnvironmentCreateRequest
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiCreateEnvironmentRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiCreateEnvironmentRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiCreateEnvironmentRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiCreateEnvironmentRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiCreateEnvironmentRequest) EnvironmentCreateRequest(environmentCreateRequest EnvironmentCreateRequest) ApiCreateEnvironmentRequest {
	r.environmentCreateRequest = &environmentCreateRequest
	return r
}

func (r ApiCreateEnvironmentRequest) Execute() (*Environment, *http.Response, error) {
	return r.ApiService.CreateEnvironmentExecute(r)
}

/*
CreateEnvironment Create Environment

Create a new environment associated with the organization encoded in the access token. In the request body, the `name`, `region`, and `type` attributes are required. The value of the name attribute must be unique within the organization. The `billOfMaterials` attribute allows you to specify the Ping products associated with this environment.

If you have a trial license, you cannot create `PRODUCTION` environments or promote `SANDBOX` environments to `PRODUCTION`.

	@permission orgmgt:create:environment
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateEnvironmentRequest
*/
func (a *EnvironmentApiService) CreateEnvironment(ctx context.Context) ApiCreateEnvironmentRequest {
	return ApiCreateEnvironmentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Environment
func (a *EnvironmentApiService) CreateEnvironmentExecute(r ApiCreateEnvironmentRequest) (*Environment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Environment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentApiService.CreateEnvironment")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.environmentCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &APIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v InvalidRequestError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v UnexpectedServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteEnvironmentByIdRequest struct {
	ctx                        context.Context
	ApiService                 *EnvironmentApiService
	environmentID              uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiDeleteEnvironmentByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiDeleteEnvironmentByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiDeleteEnvironmentByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiDeleteEnvironmentByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiDeleteEnvironmentByIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteEnvironmentByIdExecute(r)
}

/*
DeleteEnvironmentById Delete Environment

Delete an environment from the organization.

	@permission orgmgt:delete:environment
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiDeleteEnvironmentByIdRequest
*/
func (a *EnvironmentApiService) DeleteEnvironmentById(ctx context.Context, environmentID uuid.UUID) ApiDeleteEnvironmentByIdRequest {
	return ApiDeleteEnvironmentByIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
func (a *EnvironmentApiService) DeleteEnvironmentByIdExecute(r ApiDeleteEnvironmentByIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentApiService.DeleteEnvironmentById")
	if err != nil {
		return nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &APIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v UnexpectedServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			return localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBillOfMaterialsByEnvironmentIdRequest struct {
	ctx                        context.Context
	ApiService                 *EnvironmentApiService
	environmentID              uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetBillOfMaterialsByEnvironmentIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetBillOfMaterialsByEnvironmentIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetBillOfMaterialsByEnvironmentIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetBillOfMaterialsByEnvironmentIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetBillOfMaterialsByEnvironmentIdRequest) Execute() (*EnvironmentBillOfMaterials, *http.Response, error) {
	return r.ApiService.GetBillOfMaterialsByEnvironmentIdExecute(r)
}

/*
GetBillOfMaterialsByEnvironmentId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission orgmgt:read:environment
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiGetBillOfMaterialsByEnvironmentIdRequest
*/
func (a *EnvironmentApiService) GetBillOfMaterialsByEnvironmentId(ctx context.Context, environmentID uuid.UUID) ApiGetBillOfMaterialsByEnvironmentIdRequest {
	return ApiGetBillOfMaterialsByEnvironmentIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return EnvironmentBillOfMaterials
func (a *EnvironmentApiService) GetBillOfMaterialsByEnvironmentIdExecute(r ApiGetBillOfMaterialsByEnvironmentIdRequest) (*EnvironmentBillOfMaterials, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentBillOfMaterials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentApiService.GetBillOfMaterialsByEnvironmentId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/billOfMaterials"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &APIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v UnexpectedServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEnvironmentByIdRequest struct {
	ctx                        context.Context
	ApiService                 *EnvironmentApiService
	environmentID              uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiGetEnvironmentByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiGetEnvironmentByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiGetEnvironmentByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiGetEnvironmentByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiGetEnvironmentByIdRequest) Execute() (*Environment, *http.Response, error) {
	return r.ApiService.GetEnvironmentByIdExecute(r)
}

/*
GetEnvironmentById Read One Environment

Returns data only for the environment resource identified by its ID in the request URL.

	@permission orgmgt:read:environment
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiGetEnvironmentByIdRequest
*/
func (a *EnvironmentApiService) GetEnvironmentById(ctx context.Context, environmentID uuid.UUID) ApiGetEnvironmentByIdRequest {
	return ApiGetEnvironmentByIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return Environment
func (a *EnvironmentApiService) GetEnvironmentByIdExecute(r ApiGetEnvironmentByIdRequest) (*Environment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Environment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentApiService.GetEnvironmentById")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &APIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v UnexpectedServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceBillOfMaterialsByEnvironmentIdRequest struct {
	ctx                                      context.Context
	ApiService                               *EnvironmentApiService
	environmentID                            uuid.UUID
	xPingExternalTransactionID               *string
	xPingExternalSessionID                   *string
	environmentBillOfMaterialsReplaceRequest *EnvironmentBillOfMaterialsReplaceRequest
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiReplaceBillOfMaterialsByEnvironmentIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiReplaceBillOfMaterialsByEnvironmentIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiReplaceBillOfMaterialsByEnvironmentIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiReplaceBillOfMaterialsByEnvironmentIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiReplaceBillOfMaterialsByEnvironmentIdRequest) EnvironmentBillOfMaterialsReplaceRequest(environmentBillOfMaterialsReplaceRequest EnvironmentBillOfMaterialsReplaceRequest) ApiReplaceBillOfMaterialsByEnvironmentIdRequest {
	r.environmentBillOfMaterialsReplaceRequest = &environmentBillOfMaterialsReplaceRequest
	return r
}

func (r ApiReplaceBillOfMaterialsByEnvironmentIdRequest) Execute() (*EnvironmentBillOfMaterials, *http.Response, error) {
	return r.ApiService.ReplaceBillOfMaterialsByEnvironmentIdExecute(r)
}

/*
ReplaceBillOfMaterialsByEnvironmentId _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission orgmgt:update:environment
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiReplaceBillOfMaterialsByEnvironmentIdRequest
*/
func (a *EnvironmentApiService) ReplaceBillOfMaterialsByEnvironmentId(ctx context.Context, environmentID uuid.UUID) ApiReplaceBillOfMaterialsByEnvironmentIdRequest {
	return ApiReplaceBillOfMaterialsByEnvironmentIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return EnvironmentBillOfMaterials
func (a *EnvironmentApiService) ReplaceBillOfMaterialsByEnvironmentIdExecute(r ApiReplaceBillOfMaterialsByEnvironmentIdRequest) (*EnvironmentBillOfMaterials, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *EnvironmentBillOfMaterials
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentApiService.ReplaceBillOfMaterialsByEnvironmentId")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}/billOfMaterials"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.environmentBillOfMaterialsReplaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &APIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v UnexpectedServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceEnvironmentByIdRequest struct {
	ctx                        context.Context
	ApiService                 *EnvironmentApiService
	environmentID              uuid.UUID
	xPingExternalTransactionID *string
	xPingExternalSessionID     *string
	environmentReplaceRequest  *EnvironmentReplaceRequest
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single PingOne API request. It identifies one transaction that encompasses multiple API requests to PingOne.
func (r ApiReplaceEnvironmentByIdRequest) XPingExternalTransactionID(xPingExternalTransactionID string) ApiReplaceEnvironmentByIdRequest {
	r.xPingExternalTransactionID = &xPingExternalTransactionID
	return r
}

// In order to help track transactions, the PingOne platform supports this custom HTTP header that represents a scope larger than a single transaction. It identifies multiple transactions in the context of a session. For example, an end user completed an authentication request and several transactions one hour ago and now needs to re-authenticate. The session should be the same.
func (r ApiReplaceEnvironmentByIdRequest) XPingExternalSessionID(xPingExternalSessionID string) ApiReplaceEnvironmentByIdRequest {
	r.xPingExternalSessionID = &xPingExternalSessionID
	return r
}

func (r ApiReplaceEnvironmentByIdRequest) EnvironmentReplaceRequest(environmentReplaceRequest EnvironmentReplaceRequest) ApiReplaceEnvironmentByIdRequest {
	r.environmentReplaceRequest = &environmentReplaceRequest
	return r
}

func (r ApiReplaceEnvironmentByIdRequest) Execute() (*Environment, *http.Response, error) {
	return r.ApiService.ReplaceEnvironmentByIdExecute(r)
}

/*
ReplaceEnvironmentById _TO_BE_DEFINED_

_TO_BE_DEFINED_

	@permission orgmgt:update:environment
	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param environmentID An environment's unique identifier in UUID format.
	@return ApiReplaceEnvironmentByIdRequest
*/
func (a *EnvironmentApiService) ReplaceEnvironmentById(ctx context.Context, environmentID uuid.UUID) ApiReplaceEnvironmentByIdRequest {
	return ApiReplaceEnvironmentByIdRequest{
		ApiService:    a,
		ctx:           ctx,
		environmentID: environmentID,
	}
}

// Execute executes the request
//
//	@return Environment
func (a *EnvironmentApiService) ReplaceEnvironmentByIdExecute(r ApiReplaceEnvironmentByIdRequest) (*Environment, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Environment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentApiService.ReplaceEnvironmentById")
	if err != nil {
		return localVarReturnValue, nil, &APIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/environments/{environmentID}"
	localVarPath = strings.Replace(localVarPath, "{"+"environmentID"+"}", url.PathEscape(parameterValueToString(r.environmentID, "environmentID")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xPingExternalTransactionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Transaction-ID", r.xPingExternalTransactionID, "simple", "")
	}
	if r.xPingExternalSessionID != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-Ping-External-Session-ID", r.xPingExternalSessionID, "simple", "")
	}
	// body params
	localVarPostBody = r.environmentReplaceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	logDeprecationHeaders(localVarHTTPResponse.Header, localVarPath, localVarHTTPMethod)

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &APIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorResponseBadRequest
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v AccessFailedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v NotFoundError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v RequestLimitedError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v UnexpectedServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			return localVarReturnValue, localVarHTTPResponse, getErrorObject(v)
		}
		if localVarHTTPResponse.StatusCode == 502 {
			var v ServiceError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &APIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
